const d="souda_meta",l="hallOfFame";async function m(){return new Promise((t,a)=>{const s=indexedDB.open(d,4);s.onerror=()=>a(s.error),s.onsuccess=()=>t(s.result),s.onupgradeneeded=c=>{const o=c.target.result;o.objectStoreNames.contains("metaProgression")||o.createObjectStore("metaProgression"),o.objectStoreNames.contains("tutorial")||o.createObjectStore("tutorial"),o.objectStoreNames.contains("unlocks")||o.createObjectStore("unlocks"),o.objectStoreNames.contains("hallOfFame")||o.createObjectStore("hallOfFame",{keyPath:"id"})}})}async function f(t){const a=await m();return new Promise((s,c)=>{const n=a.transaction([l],"readwrite").objectStore(l).put(t);n.onerror=()=>c(n.error),n.onsuccess=()=>s()})}async function b(){const t=await m();return new Promise((a,s)=>{const r=t.transaction([l],"readonly").objectStore(l).getAll();r.onerror=()=>s(r.error),r.onsuccess=()=>{const n=r.result;n.sort((u,e)=>e.timestamp-u.timestamp),a(n)}})}async function g(){const t=await b();if(t.length===0)return{totalRuns:0,victories:0,defeats:0,bestDays:0,bestGold:0,totalLegendaryItems:0,totalCombatsWon:0,totalCombatsLost:0};const a=t.filter(e=>e.endType==="victory").length,s=t.filter(e=>e.endType!=="victory").length,c=Math.max(...t.map(e=>e.daysLived)),o=Math.max(...t.map(e=>e.finalGold)),r=t.reduce((e,i)=>e+i.legendaryItems.length,0),n=t.reduce((e,i)=>e+i.combatsWon,0),u=t.reduce((e,i)=>e+i.combatsLost,0);return{totalRuns:t.length,victories:a,defeats:s,bestDays:c,bestGold:o,totalLegendaryItems:r,totalCombatsWon:n,totalCombatsLost:u}}export{g as a,b as g,f as s};
